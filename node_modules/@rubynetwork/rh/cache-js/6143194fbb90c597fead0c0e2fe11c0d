/*hammerhead|script|start*/if (typeof window !== 'undefined' && window){window['hammerhead|process-dom-method'] && window['hammerhead|process-dom-method']();if (window.__get$ && typeof __get$ === 'undefined')var __get$Loc = window.__get$Loc,__set$Loc = window.__set$Loc,__set$ = window.__set$,__get$ = window.__get$,__call$ = window.__call$,__get$Eval = window.__get$Eval,__proc$Script = window.__proc$Script,__proc$Html = window.__proc$Html,__get$PostMessage = window.__get$PostMessage,__get$ProxyUrl = window.__get$ProxyUrl,__rest$Array = window.__rest$Array,__rest$Object = window.__rest$Object,__arrayFrom$ = window.__arrayFrom$;} else {if (typeof __get$ === 'undefined')var __get$Loc = function(l){return l},__set$Loc = function(l,v){return l = v},__set$ = function(o,p,v){return o[p] = v},__get$ = function(o,p){return o[p]},__call$ = function(o,p,a){return o[p].apply(o,a)},__get$Eval = function(e){return e},__proc$Script = function(s){return s},__proc$Html = function(h){return h},__get$PostMessage = function(w,p){return arguments.length===1?w.postMessage:p},__get$ProxyUrl = function(u,d){return u},__rest$Array = function(a,i){return Array.prototype.slice.call(a, i)},__rest$Object = function(o,p){var k=Object.keys(o),n={};for(var i=0;i<k.length;++i)if(p.indexOf(k[i])<0)n[k[i]]=o[k[i]];return n},__arrayFrom$ = function(r){if(!r)return r;return!Array.isArray(r)&&"function"==typeof r[Symbol.iterator]?Array.from(r):r};if (typeof importScripts !== "undefined" && /\[native code]/g.test(importScripts.toString())) {var __getWorkerSettings$ = function () {return null};importScripts((location.origin || (location.protocol + "//" + location.host)) + "/worker-hammerhead.js");}}/*hammerhead|script|processing-header-end*/
function checkIfConnected() {
    if (firebase.auth(window.currentApp).currentUser === null || firebase.auth(window.currentApp).currentUser.isAnonymous) {
        let response = AuthResponse.Error("Not connected")
        returnAuthResponse(response);
        return;
    }

    returnIdToken();
}

function signInWithGoogle() {
    let provider = new firebase.auth.GoogleAuthProvider();

    // When signing in with an anonymous user, try and link the account with popup.
    if (firebase.auth(window.currentApp).currentUser !== null && firebase.auth(window.currentApp).currentUser.isAnonymous) {
        window.currentApp = window.anonymousApp;

        firebase.auth(window.currentApp).currentUser
            .linkWithPopup(provider)
            .then((result) => {
                const tempApp = window.mainApp;
                window.mainApp = window.anonymousApp;
                window.anonymousApp = tempApp;
                window.currentApp = window.mainApp;
                
                returnIdToken();
            }).catch((error) => {
                if (error.credential !== undefined && error.credential !== null) {
                    window.currentApp = window.mainApp;
                    
                    // If linking user fails, then sign into their account regularly.
                    firebase.auth(window.currentApp)
                        .signInWithCredential(error.credential)
                        .then((result) => {
                            returnIdToken();
                        }).catch((error) => {
                        let response = AuthResponse.Error(error)
                        returnAuthResponse(response);
                    })
                } else {
                    let response = AuthResponse.Error(error)
                    returnAuthResponse(response);
                }
        })
    } else {
        window.currentApp = window.mainApp;

        // When not using anonymous user, sign in as usual via popup
        firebase.auth(window.currentApp)
            .signInWithPopup(provider)
            .then((result) => {
                returnIdToken()
            }).catch((error) => {
            let response = AuthResponse.Error(error)
            returnAuthResponse(response);
        });
    }
}

function signInAnonymously() {
    window.currentApp = window.anonymousApp;

    firebase.auth(window.currentApp).signInAnonymously()
        .then(() => {
            returnIdToken()
        })
        .catch((error) => {
            let response = AuthResponse.Error(error)
            returnAuthResponse(response);
        });
}

/**
 Used from PC only
 */
function firebaseLogin(providerName) {
    let provider = getProvider(providerName);
    window.currentApp = window.mainApp;

    firebase.auth(window.currentApp).useDeviceLanguage();
    firebase.auth(window.currentApp).signInWithRedirect(provider);
}

// This is being called directly from unity. 
function signOut() {
    let response;

    firebase.auth(window.currentApp).signOut().then(() => {
        response = AuthResponse.Success("loggedOut")
    }).catch((error) => {
        response = AuthResponse.Error(error)
    }).finally(() => {
        returnAuthResponse(response);
    });
}

function getProvider(providerName) {
    if (providerName && providerName.indexOf("facebook") !== -1)
        return new firebase.auth.FacebookAuthProvider()
    else
        return new firebase.auth.GoogleAuthProvider()
}

function returnIdToken() {
    let response;

    firebase.auth(window.currentApp).currentUser.getIdToken(true)
        .then((token) => {
            response = AuthResponse.Success(token)
        })
        .catch(function (error) {
            response = AuthResponse.Error(error)

        }).finally(() => {
        returnAuthResponse(response);
    });
}


function returnAuthResponse(response) {
    window.unityInstance.SendMessage('PersistentObjects', 'OnGotWebResponse', JSON.stringify(response));
}

class AuthResponse {
    constructor(taskResult, response) {
        this.Result = taskResult === undefined ? "" : taskResult;
        this.Response = response === undefined ? "" : response;
    }

    static Success(token) {
        return new AuthResponse(AuthTaskResult.Success, token)
    }

    static Cancelled() {
        return new AuthResponse(AuthTaskResult.Cancelled, "Cancelled")
    }

    static Error(error) {
        return new AuthResponse(AuthTaskResult.Error, error)
    }
}

class AuthTaskResult {
    static Success = "Success"
    static Cancelled = "Cancelled"
    static Error = "Error"
}
/*hammerhead|script|end*/